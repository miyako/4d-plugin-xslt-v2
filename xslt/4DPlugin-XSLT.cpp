/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-XSLT.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : XSLT
 #	author : miyako
 #	2019/09/17
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-XSLT.h"

#pragma mark -

void OnStartup()
{
    xmlInitParser();
    exsltRegisterAll();
    
    /*
     xmlMemSetup must be the very first call to libxml2 then call
         xmlInitParser(). Don't call xmlInitMemory by yourself, xmlInitParser
         will do it.
         https://mail.gnome.org/archives/xml/2007-August/msg00037.html
     */
}

void OnExit()
{
    xsltCleanupGlobals();
    xmlCleanupParser();
    
    /*
     WARNING: if your application is multithreaded or has plugin support calling this may crash the application if another thread or a plugin is still using libxml2. It's sometimes very hard to guess if libxml2 is in use in the application, some libraries or plugins may use it without notice. In case of doubt abstain from calling this function or do it just before calling exit() to avoid leak reports from valgrind !
         http://xmlsoft.org/html/libxml-parser.html#xmlCleanupParser
     */
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
#ifdef _WIN64
				PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnStartup, NULL);
#else
				OnStartup();
#endif // _WIN64
                break;
                
            case kDeinitPlugin :
#ifdef _WIN64
				PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnExit, NULL);
#else
				OnExit();
#endif // _WIN64
                
                break;
                
			// --- XSLT
            
			case 1 :
				XSLT_Apply_stylesheet(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

BOOL is_file_path(C_BLOB& h) {
    
    BOOL result = FALSE;
            
    PA_long32 size = h.getBytesLength();
    
    if(size < 1024) {
        
        C_TEXT t;
        t.setUTF8String((const uint8_t *)h.getBytesPtr(), size);
        
        PA_Variable    params[1];
        params[0] = PA_CreateVariable(eVK_Unistring);
        PA_Unistring path = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
        PA_SetStringVariable(&params[0], &path);
        result = (1 == PA_GetLongintVariable(PA_ExecuteCommandByID(476 /* test path name */, params, 1)));
        PA_ClearVariable(&params[0]);

    }

    return result;
}

xmlDocPtr parse_xml_doc(C_BLOB& h, int options) {
    
    xmlDocPtr xmlDoc = 0;
    
    if(is_file_path(h))
    {
        /* convert path hfs to posix */
        
        //the blob is not null-terminated!
        std::string buf = std::string((const char *)h.getBytesPtr(), h.getBytesLength());
        
#if VERSIONMAC
        NSString *str = [[NSString alloc]initWithUTF8String:buf.c_str()];
        if(str) {
            
            NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault,
                                                                (CFStringRef)str, kCFURLHFSPathStyle, false);
            if(url) {
                NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
                if(path) {
                    xmlDoc = xmlParseFile((const char *)[path UTF8String]);
                    [path release];
                }
                [url release];
            }
            [str release];
        }
#else
        xmlDoc = xmlParseFile((const char *)buf.c_str());
#endif

    }else
    {
        xmlDoc = xmlParseMemory((const char *)h.getBytesPtr(), h.getBytesLength());
    }
    
    if(xmlDoc) {
        xmlXIncludeProcessFlags(xmlDoc, options);
    }
     
    return xmlDoc;
}

xsltStylesheetPtr parse_xsl_doc(C_BLOB& h, int options) {
    
    xsltStylesheetPtr xslDoc = 0;
    
    xmlDocPtr xmlDoc = parse_xml_doc(h, options);
    
    if(xmlDoc) {
        /* xsltFreeStylesheet(xslDoc) will free xmlDoc */
        xslDoc = xsltParseStylesheetDoc(xmlDoc);
    }
    
    return xslDoc;
}

#pragma mark -

void XSLT_Apply_stylesheet(PA_PluginParameters params) {

    C_BLOB returnValue;
       
    bool didReturn = false;
    
//    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB xml;
    xml.fromParamAtIndex(pParams, 1);
    
    C_BLOB xsl;
    xsl.fromParamAtIndex(params, 2);
    
    std::vector<const char *> xslParams;
    std::vector<std::string> xslParamsValues;
    
    CUTF8String json_options;
    PA_ObjectRef options = PA_GetObjectParameter(params, 3);
    if(options) {
        ob_stringify(options, &json_options);
        Json::Value root;
        Json::CharReaderBuilder builder;
        std::string errors;
        
        Json::CharReader *reader = builder.newCharReader();
        bool parse = reader->parse((const char *)json_options.c_str(),
                                   (const char *)json_options.c_str() + json_options.size(),
                                   &root,
                                   &errors);
        if(parse)
        {
            if(root.isObject())
            {
                for(Json::Value::const_iterator it = root.begin() ; it != root.end() ; it++)
                {
                    Json::Value key = it.key();
                    JSONCPP_STRING name = it.name();
                    
                    
                    if(it->isString())
                    {
                        xslParamsValues.push_back(std::string(key.asString())); 
                        xslParamsValues.push_back(std::string(it->asString()));
                    }
                }
            }
        }
    }
    
    for(size_t i = 0; i < xslParamsValues.size(); ++i) {
       xslParams.push_back(xslParamsValues.at(i).c_str());
    }
    
    xslParams.push_back(NULL);

    int xmlParserOption = XSLT_PARSE_OPTIONS;
    int xslParserOption = XSLT_PARSE_OPTIONS;
    
    if(ob_is_defined(options, L"xmlParserOption"))
    {
        xmlParserOption |= (int)ob_get_n(options, L"xmlParserOption");
    }
    
    if(ob_is_defined(options, L"xslParserOption"))
    {
        xslParserOption |= (int)ob_get_n(options, L"xslParserOption");
    }

    xmlDocPtr xmlDoc = parse_xml_doc(xml, xmlParserOption);
    if (xmlDoc) {
        xsltStylesheetPtr xslDoc = parse_xsl_doc(xsl, xslParserOption);
        if(xslDoc) {
            
            xsltTransformContextPtr ctxt = xsltNewTransformContext(xslDoc, xmlDoc);
            
            xmlDocPtr outDoc = xsltApplyStylesheetUser (xslDoc,
                                                        xmlDoc, &xslParams[0],
                                                        NULL, NULL, ctxt);
            
            if(outDoc)
            {
                xmlOutputBufferPtr outputBuffer = xmlAllocOutputBuffer(0);
                if(outputBuffer) {
                    // mysteriously, 0 is returned
                    // http://xmlsoft.org/XSLT/html/libxslt-xsltutils.html#xsltSaveResultTo
                    int bytesWritten = xsltSaveResultTo (outputBuffer, outDoc, xslDoc);
                    size_t resultLength = xmlOutputBufferGetSize(outputBuffer);
                    if (resultLength)
                    {
                        PA_ReturnBlob(params, (void *)xmlOutputBufferGetContent(outputBuffer), (PA_long32)resultLength);
                        didReturn = true;
                    }
                    xmlOutputBufferClose(outputBuffer);
                }
                xmlFreeDoc(outDoc);
            }
            xsltFreeStylesheet(xslDoc);
        }
        if(xmlDoc) xmlFreeDoc(xmlDoc);
    }
    
    if(!didReturn){
        PA_ReturnBlob(params, (void *)"", (PA_long32)0L);
    }
}

